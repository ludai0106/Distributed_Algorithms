import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

public class Process extends UnicastRemoteObject implements ProcessInterface{
	/**
	 * 
	 */
	private static final long serialVersionUID = -6044439435459038975L;
	private int processId;
    private int processNum;
    private Clock clock;
    private Registry registry;
    private int remotes;
    public Process( int port, int processId, int processNum) throws RemoteException, AlreadyBoundException{
        this.processId = processId;
        this.processNum = processNum;
        this.clock = new Clock(processNum);
        this.registry = LocateRegistry.getRegistry(port);
        this.registry.bind(Integer.toString(processId), this);
    }

    public int getProcessId(){
        return processId;
    }

    public Clock getClock(){
        return clock;
    }

    public void deliverMessage(Message message, String receiver ){}

    public void broadcastMessage(Message message){
    	System.out.println(message.toStringBroadcast());
    }
    
    public void receiveMessage(Message message){
    	if(message.getClock().sendCondition(this.clock)){
    		System.out.println(message.toStringReceive());
    		this.clock.update(message.getClock());
    	}
    	else{
    		
    	}
    }
    
    public void notifyRemotes(){
    	String[] processes;
		try {
			processes = this.registry.list();
			for(String processName: processes){
				ProcessInterface remoteProcess = (ProcessInterface) this.registry.lookup(processName);
				remoteProcess.registerNode();
				System.out.println("Notified node: " + nodeName);
				nodesJoined++;		
			}
		} catch (Exception e) {
			System.out.println("Exception in notifyOthers" + e);
		}
    }
    
	public void registerNode() throws RemoteException {
		nodesJoined++;
		if(nodesJoined-1 == networkSize)
			algorithm();
	}


}
