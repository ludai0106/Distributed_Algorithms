import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.rmi.AccessException;
import java.rmi.AlreadyBoundException;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.Random;

public class Process extends UnicastRemoteObject implements IProcess {

	
	/**
	 * 
	 */
	private static final long serialVersionUID = -6217181541080759395L;
	private int processId;
	private int processNum;
	private Registry registry;
	public Clock clock;
	int index;
	ArrayList<Message> buffer = new ArrayList<Message>();
	int messageNumber;

	protected Process(int registryPort, int processId, int ProcessNum) throws RemoteException {
		super();
		this.setProcessId(processId);
		this.processNum = ProcessNum;
		this.setRegistry(LocateRegistry.getRegistry(registryPort));
		clock = new Clock(ProcessNum);
		try {
			this.getRegistry().bind(Integer.toString(this.getProcessId()),this);
		} catch (AlreadyBoundException e) {
			System.out.println("Already bound" + e);
		}
		index = this.getRegistry().list().length-1;
		messageNumber = 0;
	}
	
	public void notifyProcess(){
		String[] nodes;
		try {
			nodes = this.getRegistry().list();
			for(String nodeName: nodes){
				IProcess remoteNode = getRemoteNode(nodeName);
				remoteNode.registerNode(nodes.length);
				System.out.println("Notified node: " + nodeName);
//				nodesJoined++;		
			}
		} catch (Exception e) {
			System.out.println("Exception in notifyOthers" + e);
		}
	}
	
//	public void algorithm(){
//		final Process currentNode = this;
//		final double start = System.currentTimeMillis(); 
//		new Thread(new Runnable(){
//			public void run(){
//				try{
//					String[] remoteIds = currentNode.registry.list();
//					while(true & (System.currentTimeMillis() - start) < 3000){
//						currentNode.getVectorClock().increment(index);
//						Clock currentClock = currentNode.getVectorClock();
//						messageNumber++;
//						
//						String processIdS = Integer.toString(currentNode.processId);
//						String message = messageNumber + ". Hello ";
//						Message m = new Message(processIdS, message, currentClock);
//						currentNode.broadcastMessage(m);	
//						for(String nodeId: remoteIds){
//							
//							IProcess remoteNode = currentNode.getRemoteNode(nodeId);
//							if(!processIdS.equals(nodeId)){
//								Message m2 = new Message(processIdS, nodeId, message, currentClock);
//								Thread.sleep(randomNumber(5,350));
//								//Thread.sleep(100);
//								remoteNode.receiveMessage(m2);
//							}	
//						}
//						Thread.sleep(randomNumber(5,50));
//					}
//					
//				}catch (Exception e) {
//					System.out.println("Exception in broadCast " + e);
//				}
//			}
//			
//		}).start();
//		
//	}
	


	public void broadcastMessage(Message m) throws RemoteException {		
		String s = m.toStringBroadcast();
		writeFile(s);
		System.out.println(s);
	}
	
	public void receiveMessage(Message m) throws RemoteException {		
		
		if(!m.getClock().passCondition(this.getVectorClock())){
			System.out.println(m.toStringReceive() +", own: " + clock + " buffer");
			synchronized(this) {
				
				for(int i = 0;i < buffer.size(); i++){
					Message messageB = buffer.get(i);
					System.out.println(messageB.getClock() + "passconditon" + this.getVectorClock());
					if(messageB.getClock().passCondition(this.getVectorClock())){
						System.out.println(messageB.toStringReceive() +", own: " + clock + " retry");
						clock.increment(index);
						Clock maxClock = clock.compareClocks(messageB.getClock(),this.getVectorClock());
					    
						this.setVectorClock(maxClock);
						//System.out.println(maxClock.toString());

						buffer.remove(i); //TODO index might get confused					
					}
				}
				buffer.add(m);
			}
		}
		else{
			System.out.println(m.toStringReceive() +", own: " + clock);
			//this.setVectorClock(m.getVectorClock());
			clock.increment(index);
			Clock maxClock = clock.compareClocks(m.getClock(),this.getVectorClock());
			
			this.setVectorClock(maxClock);
			//System.out.println(maxClock.toString());
			
		}
		
	}
	
	public synchronized void writeFile(String message){
		try
		{
		    String filename= "myfile.txt";
		    FileWriter fw = new FileWriter(filename,true); //the true will append the new data
		    fw.write(message+ "\n");//appends the string to the file
		    fw.close();
		}
		catch(IOException ioe)
		{
		    System.err.println("IOException: " + ioe.getMessage());
		}
	}
	
	IProcess getRemoteNode(String nodeStringId) throws AccessException, RemoteException, NotBoundException {
		IProcess remoteNode = (IProcess) this.getRegistry().lookup(nodeStringId);
		return remoteNode;
	}

	public void registerNode(int length) throws RemoteException {
//		nodesJoined++;
		if(length == processNum){
			final Process currentProcess = this;
			final double start = System.currentTimeMillis();
			Broadcast broadcast = new Broadcast(currentProcess,2,index,start);
			Thread broadcastThread = new Thread(broadcast.run());
			broadcastThread.start();
			
		}
	}
	
	public Clock getVectorClock(){
		return clock;		
		
	}
	
	public void setVectorClock(Clock clockNew){
		clock = clockNew;		
	}

	public Registry getRegistry() {
		return registry;
	}

	public void setRegistry(Registry registry) {
		this.registry = registry;
	}

	public int getProcessId() {
		return processId;
	}

	public void setProcessId(int processId) {
		this.processId = processId;
	}
	

}
